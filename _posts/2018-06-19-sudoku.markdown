---
layout: post
title : "数独演算法的设计、优化与分析"
author: "siahuat0727"
tags:
    - sudoku
    - 数独
    - 设计
    - 实作
    - 分析
    - 拟人解法
    - C
    - C++
---

## 前言

解数独是刚接触程式时的第一份作业，
如果有大神路过，

## 解法一： 传统 Backtracking

这大概是最常见的解法，[bactracking](https://en.wikipedia.org/wiki/Backtracking)的精神就不在此赘述，大概就是按照一定的顺序进行[试错](https://zh.wikipedia.org/wiki/%E8%AF%95%E9%94%99)([trial and error](https://en.wikipedia.org/wiki/Trial_and_error))，若某一步走不下去了便返回上一步继续之前的试错。

以下为使用此法解数独的过程： [gif 来源](https://en.wikipedia.org/wiki/Backtracking#/media/File:Sudoku_solved_by_bactracking.gif)

![](/img/in-post/sudoku/backtracking_sudoku.gif)

```c?line_numbers=true
#define N 9
int ans_count;
int sudoku[N][N];
```

*`sudoku[N][N]`储存 9x9 格的数字，０表示空白。*
```c
void next_bt(int r, int c)
{
    c == N-1 ? bt(r+1, 0) : bt(r, c+1);
}

void bt(int r, int c)
{
    if (r == N) {
        ans_count++;
        sudoku_print();
        return;
    }
    if (sudoku[r][c] != 0)
        next_bt(r, c);
    else {
        for (int n = 1; n <= N; ++n) {
            if (can_fill(r, c, n)) {
                sudoku[r][c] = n;
                next_bt(r, c);
                sudoku[r][c] = 0;
            }
        }
    }
}

// call bt(0, 0) to solve
```
*`next_bt(r, c)`由左至右，由上而下,依序进行试错*
*`bt(r, c)`对数独的第`r`row, 第`c`col试错*
>原本看到`next_bt(r, c)`这种只有一两行的 funcion 想说加上 [inline](http://en.cppreference.com/w/cpp/language/inline) 减少 call function 的 overhead 来增快速度，实测上也确实有微小的增快，但后来用了 GNU 自带的 [optimization flag](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html) -O2 后，增快的幅度是以倍数来计算的！而加上 inline 的优化后反而慢了一点……所以如果可以自己 compile 的话或许就不用考虑用 inline 来加速吧。

```c++
bool can_fill_row(int r, int n)
{
    for (int c = 0; c < N; ++c)
        if (sudoku[r][c] == n)
            return false;
    return true;
}

bool can_fill_col(int c, int n)
{
    for (int r = 0; r < N; ++r)
        if (sudoku[r][c] == n)
            return false;
    return true;
}

bool can_fill_box(int r, int c, int n)
{
    int r_start = r/3 * 3;
    int c_start = c/3 * 3;
    for (int i = r_start; i < r_start+3; ++i)
        for (int j = c_start; j < c_start+3; ++j)
            if (sudoku[i][j] == n)
                return false;
    return true;
}

bool can_fill(int r, int c, int n)
{
    return can_fill_row(r, n) && can_fill_col(c, n) && can_fill_box(r, c, n);
}
```
*`can_fill_row(r, n)`寻找第 `r` row是否已存在数字`n`，以此类推。*
*`box`表示数独中的宫 (小 3x3)。*
*第 19 行`r_start = r/3 * 3`取得`r`所在之宫的 row 起始位置，`c_start` 同理。*


## 解法二： 优化版 Backtracking

解法一的 `can_fill(r, c, n)` 每次重新看过空白处所在之行、列、宫是否存在数字`n`，而这件事可以通过新增一些变数来实时记录。（非常经典的用**空间**换**时间**）
```c++
bool row[N][N+1];
bool col[N][N+1];
bool box[N][N+1];
```
*`row[r][n]` 表示第 `r` row 是否存在数字 `n`，以此类推。*

```c++
int get_box(int r, int c)
{
    return r/3*3 + c/3;
}

bool can_fill(int r, int c, int n)
{
    return !row[r][n] && !col[c][n] && !box[get_box(r,c)][n];
}
```
*`get_box(r, c)`找到`r, c`对应的`box`编号。编号由左至右，由上而下，依序为 0-8。其对应关系通过尝试几组`r, c`不难发觉。*

这样一来，原本 O(n) 的`can_fill(r, c, n)`就可以在 O(1) 时间内完成了！~~（虽然原本的 O(n) 的 n 也只是 9）~~

而我们只需要在每次更改数独中的值时同步更新这些变数：

也就是将解法一的 `bt(r, c)` 中的

```c
                sudoku[r][c] = n;
                next_bt(r, c);
                sudoku[r][c] = 0;
```

改为：

```c
                fill(r, c, n);
                next_bt(r, c);
                erase(r, c, n);
```

其中
```c++
void _fill(int r, int c, int n, bool b)
{
    row[r][n] = b;
    col[c][n] = b;
    box[get_box(r,c)][n] = b;
    sudoku[r][c] = b ? n : 0;
}

void fill(int r, int c, int n)
{
    _fill(r, c, n, true);
}

void erase(int r, int c, int n)
{
    _fill(r, c, n, false);
}
```

## 解法三： 初步拟人

解法一、二虽然可行，但每一步都用猜的，具不确定性，而很多时候有些空白处就只能填一个数字。（是确定的）
若每次都先填入这些已知正确的数字，就可以减少很多不必要的尝试。

在较难的数独上，我们也会遇到瓶颈（每个空白处都有超过一个数字可填），这时可以选择一个空白处进行试错后，再重复本解法。(有一点点Backtracking的感觉)

这就好像先把所有确定的格子填好后发现做不下去，只好影印一份，先在影本猜其中一格再继续往下做。
当然就算是已经有一个格用猜的影本也可能出现做不下去的情况，这时就需要将这影本拿去影印，去尝试解这影本的影本。

啰嗦几句，为什么要拿去影印呢？
举个例子，当我们遇到瓶颈时，若先尝试在某一格填入数字 2，解一解发现无解（某空白处无法被填入任何数字），这表示刚刚猜的数字 2 是错误的，那么假设没有事先影印，就没办法恢复到之前的状态了。

先以 pseudo code 的方式呈现：

```
solve(Sudoku s)
{
    do {
        for each empty cell of Sudoku s {
            若只能填唯一数字则填之   // 若在此处发现没有可填数表示此 Sudoku s 无解
        }
    } while (这一次 loop 有找到可填数字); // 若1个完整 loop 找不到任何数字可填，
                                      // 那么就算再 loop 几次也不会有结果
    if (没空白处了) {
        输出解
    } else {
        for each 第一个空白处的可填数字 n:
            s'  <-  s 填入 数字n
            solve(s')
    }
}
```
由于这种解法有可能同时存在多个数独，所以不能再用全域变数打天下了，先定义
```c++
typedef struct _Sudoku{
    int grid[N][N];
    bool row[N][N+1];
    bool col[N][N+1];
    bool box[N][N+1];
} Sudoku;
```
主体
```c++
void sudoku_solve(Sudoku *thiz)
{
    int num_filled, num_unsolved;
    do {
        num_filled = 0;
        num_unsolved = 0;
        FOR_FOR_EACH_EMPTY_CELL(r, c, thiz) {
            int num_can_fill = 0;
            int t;
            FOR_EACH_NUM(n) {
                if(sudoku_can_fill(thiz, r, c, n)) {
                    num_can_fill++;
                    t = n;
                    if (num_can_fill > 1) // pruning
                        break;
                }
            }
            if (num_can_fill == 0) // no solution
                return;
            if (num_can_fill == 1) {
                sudoku_fill(thiz, r, c, t);
                num_filled++;
            } else
                num_unsolved++;
        }
    } while (num_filled != 0);
    if (num_unsolved == 0) {
        ans_count++;
        sudoku_print(thiz);
    } else {
        // find the first empty cell, try to fill and solve it
        FOR_FOR_EACH_EMPTY_CELL(r, c, thiz) {
            FOR_EACH_NUM(n) {
                if (sudoku_can_fill(thiz, r, c, n)) {
                    sudoku_fill(thiz, r, c, n);

                    // copy and solve
                    Sudoku sudoku_tmp;
                    memcpy(&sudoku_tmp, thiz, sizeof(Sudoku));
                    sudoku_solve(&sudoku_tmp);

                    sudoku_erase(thiz, r, c, n);
                }
            }
            return;
        }
    }
}
```
*小 function 们都与之前的类似，只是新增对哪个 sudoku 做操作。比如`sudoku_can_fill(thiz, r, c, n)`与`can_fill(r, c, n)`， 前者表示针对数独`thiz`检查位置`r, c`可否填入`n`。*

其中

```
#define FOR_N(i) for (int i = 0; i < N; ++i)    
#define FOR_FOR_EACH_EMPTY_CELL(r, c, s) FOR_N(r) FOR_N(c) if(s->grid[r][c] == 0)    
#define FOR_EACH_NUM(n) for (int n = 1; n <= N; ++n)    
```

*由于有些时候遍历 0-8，有些则遍历 1-9，为了减少不必要的 bug，将其定义为 [macro](https://gcc.gnu.org/onlinedocs/cpp/Macros.html)*

另外，本法相较与 backtracking 的绝对优势就是，它可以快速发现该数独无解！（若未曾试错）
即每次填入数字都是确定的，那么在这种假设下，若有一个空白处无法填入任何数字，则表示无解。
这部分在主体中的：

```c++
            if (num_can_fill == 0)
                return;
```

## 解法四： 环保拟人

每次遇到瓶颈都要复制一整个 Sudoku (9×9=**81 int** + 3×9×10=**270 bool**)，好像没必要？

解法三中，影印的比喻是为了配合程式实作上的便利，我想实际上一般人不会这么做。通常大家是先用原子笔填入确定正确之数字，不确定的部分改用铅笔填写，发现错了就把用铅笔填的擦掉。（用铅笔之后又遇到瓶颈时就想象用更浅的铅笔来填）

我们可以运用 [stack](http://www.cplusplus.com/reference/stack/stack/) 来保留每次开始尝试之后所填下的数字。

这种做法实际上不会比较快（维护 stack 所需的时间成本较高），但好处是就算一直遇到瓶颈也只会存在一份数独。

以下借用 C++ 的 stack 来完成

```c++
void _sudoku_solve(Sudoku *thiz, stack<Cell> *s, bool record)
{
    int n_filled, n_unsolved;
    do {
        n_filled = 0;
        n_unsolved = 0;
        FOR_FOR_EACH_EMPTY_CELL(r, c, thiz) {
            int n_can_fill = 0;
            int t;
            FOR_EACH_NUM(n) {
                if(sudoku_can_fill(thiz, r, c, n)) {
                    n_can_fill++;
                    t = n;
                    if (n_can_fill > 1) // pruning  
                        break;
                }
            }
            if (n_can_fill == 0) // no solution
                return;
            if (n_can_fill == 1) {
                sudoku_fill(thiz, r, c, t);
                n_filled++;
                if (record) {
                    Cell cell = {.r=r, .c=c, .n=t};
                    s->push(cell);
                }
            } else
                n_unsolved++;
        }
    } while (n_filled != 0);
    if (n_unsolved == 0) {
        ans_count++;
        sudoku_print(thiz);
    } else {
        // find the first empty cell, try to fill and solve it
        FOR_FOR_EACH_EMPTY_CELL(r, c, thiz) {
            FOR_EACH_NUM(n) {
                if (sudoku_can_fill(thiz, r, c, n)) {
                    sudoku_fill(thiz, r, c, n);
                    sudoku_solve(thiz, true);
                    sudoku_erase(thiz, r, c, n);
                }
            }
            return;
        }
    }
}

void sudoku_solve(Sudoku *thiz, bool record=false)
{
    stack<Cell> s;
    _sudoku_solve(thiz, &s, record);
    if(record) {
        while(!s.empty()) {
            Cell cell = s.top();
            sudoku_erase(thiz, cell.r, cell.c, cell.n);
            s.pop();
        }
    }
}
```
*`record`default 为 `false` 是因为第一次不用记录（所有答案都是确定正确的）*
*可以发现第 40 行处不需要像 解法三 一样复制整个数独了*
>原本想说这部分只写成一个 function（感觉比较完整？），但 `_sudoku_solve` 共有三个有可能 return 的地方(19、44、47行)，不知若要在 return 前把 stack 里记录的数字 `erase` 掉，是要利用 goto 好呢，还是像这样拆成两个 function 呢？又或是有其它解法呢？

## 解法五： 进阶拟人

只有某格只能填一个数字时才能确定该格的解吗？
其实还有很多情况，比如在某一**行**中，某个数字就只能填在该行某一空白处时，则该数字为该空白处之解。
同理，以**列**和**宫**的角度出发也一样。

也就是说，我们除了以**格**的角度（某空白处是否只能填一个数字）来寻解之外，亦可以以**行**、**列**、**宫**的角度来观察。

如下图所示，每个观察角度的求解能力（可得出之**解集合**）是不同的：

![](/img/in-post/sudoku/PowerOfRowColBoxCell.png)

_图中 row 集合表示以 row 的角度来观察可得出解之空白处集合， col、box、cell 同理_  
_[Venn diagram](https://en.wikipedia.org/wiki/Venn_diagram) with [n = 4](https://en.wikipedia.org/wiki/File:Venn%27s_four_ellipse_construction.svg)_  
_[此图进一步解释](#解释)_

因此用越多角度来观察越有机会降低试错的次数，但这也造成一定的 overhead，具体哪种解法比较快因数独难度而异。

解法五中，我们从行、列、宫、格四种角度寻解。新增三种角度寻找的过程与以格的角度（参考解法三）类似，于是写了 ~~乱乱的~~ macro。

```c++
#define FILL_IF_EXACTLY_ONE(LOOP1, LOOP2, arg1, arg2, \
        arg3, arg4, count_unsolved, extra_stmt) \
    do { \
        LOOP1 { \
            int num_can_fill = 0; \
            int t; \
            LOOP2 { \
                if (sudoku_can_fill(thiz, r, c, n)) { \
                    num_can_fill++; \
                    t = arg4; \
                    extra_stmt; \
                    if (num_can_fill > 1) /* pruning */ \
                        break; \
                } \
            } \
            if (num_can_fill == 0) \
                return false; /* thiz can't be solved */ \
            if (num_can_fill == 1) { \
                sudoku_fill(thiz, arg1, arg2, arg3); \
                ++*num_filled; \
            } else if (count_unsolved) \
                ++*num_unsolved; \
        } \
    } while (0) 

bool sudoku_solve_row(Sudoku *thiz, int *num_filled, int *num_unsolved, bool count_unsolved)
{
    FILL_IF_EXACTLY_ONE(FOR_N(r) FOR_EACH_NUM(n) if(!thiz->row[r][n]), 
            FOR_N(c) if(!thiz->grid[r][c]), 
            r, t, n, c, count_unsolved, NULL);
    return true;
}

bool sudoku_solve_col(Sudoku *thiz, int *num_filled, int *num_unsolved, bool count_unsolved)
{
    FILL_IF_EXACTLY_ONE(FOR_N(c) FOR_EACH_NUM(n) if(!thiz->col[c][n]), 
            FOR_N(r) if(!thiz->grid[r][c]), 
            t, c, n, r, count_unsolved, NULL);
    return true;
}

bool sudoku_solve_box(Sudoku *thiz, int *num_filled, int *num_unsolved, bool count_unsolved)
{
    int t2 = 0;
    FILL_IF_EXACTLY_ONE(FOR_N(i) FOR_EACH_NUM(n) if(!thiz->box[i][n]), 
            FOR_R_C_IN_BOX(r, c, i) if(!thiz->grid[r][c]), 
            t, t2, n, r, count_unsolved, t2=c);
    return true;
}

bool sudoku_solve_cell(Sudoku *thiz, int *num_filled, int *num_unsolved, bool count_unsolved)
{
    FILL_IF_EXACTLY_ONE(FOR_FOR_EACH_EMPTY_CELL(r, c, thiz), 
            FOR_EACH_NUM(n), 
            r, c, t, n, count_unsolved, NULL);
    return true;
}

void sudoku_solve(Sudoku *thiz)
{
    int num_filled, num_unsolved;
    do {
        num_filled = 0;
        num_unsolved = 0;

        if (!sudoku_solve_row(thiz, &num_filled, &num_unsolved, false) ||
            !sudoku_solve_col(thiz, &num_filled, &num_unsolved, false) ||
            !sudoku_solve_box(thiz, &num_filled, &num_unsolved, false) ||
            !sudoku_solve_cell(thiz, &num_filled, &num_unsolved, true))
            return;

    } while (num_filled != 0);
    
    if (num_unsolved == 0) {
        ans_count++;
        sudoku_print(thiz);
    } else {
        // find the first empty cell, try to fill and solve it
        FOR_FOR_EACH_EMPTY_CELL(r, c, thiz) {
            FOR_EACH_NUM(n) {
                if (sudoku_can_fill(thiz, r, c, n)) {
                    sudoku_fill(thiz, r, c, n);

                    // copy and solve
                    Sudoku sudoku_tmp;
                    memcpy(&sudoku_tmp, thiz, sizeof(Sudoku));
                    sudoku_solve(&sudoku_tmp);

                    sudoku_erase(thiz, r, c, n);
                }
            }
            return;
        }
    }
}
```
*[Why use apparently meaningless do-while statements in macros](https://stackoverflow.com/questions/154136/why-use-apparently-meaningless-do-while-and-if-else-statements-in-macros)*

> 觉得这里为了 [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) 写得有点乱，尤其 box 角度需要在 for 里存两个资讯（其他三种只需要一个），用了 `extra_stmt`(11行) 和 `t2=c`(47行) 乱解，盼望有缘人来指点（（

再次强调，上述四种观察角度，单用任何一种或是组合使用都可以在有限时间内求解简单数独。

## 解法6： 优先试错

遇到瓶颈时，针对哪个空白处进行试错最佳呢？
答案大概很复杂，但我们可以用很简单的方式找到较佳的位置：**最少可填数的格子**
原因是**平均**来说需要较少的试错就能找到该格子的解

将 解法5 的最后部分替换为
```c
        int Min = N;
        int r_min = 0, c_min = 0;
        // find the empty cell with fewest possible answer
        FOR_FOR_EACH_EMPTY_CELL(r, c, thiz) {
            int num_can_fill = 0; 
            FOR_EACH_NUM(n) {
                if (sudoku_can_fill(thiz, r, c, n)) {
                    ++num_can_fill;
                }
            }
            if (num_can_fill < Min) {
                Min = num_can_fill;
                r_min = r;
                c_min = c;
            }
        }
        // try to fill and solve it
        FOR_EACH_NUM(n) {
            if (sudoku_can_fill(thiz, r_min, c_min, n)) {
                sudoku_fill(thiz, r_min, c_min, n);

                // copy and solve
                Sudoku sudoku_tmp;
                memcpy(&sudoku_tmp, thiz, sizeof(Sudoku));
                sudoku_solve(&sudoku_tmp);

                sudoku_erase(thiz, r_min, c_min, n);
            }
        }
```

## 效能分析



## 解释

![](/img/in-post/sudoku/PowerOfRowColBoxCell.png)


_如 w 位于可由 **cell** 或 **row**、不可由 **col** 或 **box** 观察得出之解集合_  

